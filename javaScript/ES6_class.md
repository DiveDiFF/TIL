# 6.7 클래스 (Class)

- javaScript는 프로토타입 기반 객체지향 언어다.
- 클래스 기반 객체지향 언어처럼 쓸 수 있게 만들어준 문법적 설탕이지, javaScirpt가 클래스 기반 객체지향 언어로 바뀐건 아니다. (내부 동작은 여전히 프로토타입 기반으로 동작함)
- javaScript는 생성자 함수와 프로토타입을 사용하여 객제 지향 프로그래밍을 구현함

1. class 정의

```javaScript
  class Person {
  constructor(name) { //constructor가 생성자 함수. 클래스 명이 생성자 함수명이 됨
    this._name = name;
  }

  sayHi() {
    console.log(`Hi! ${this._name}`);
  }
}
// class에선 new 안쓰면 에러남
const me = new Person('Lee');
me.sayHi(); // Hi! Lee

console.log(me instanceof Person); // true
```

> 객체 생성의 네번째 방법이라고 이해. (ES6에서 보편적으로 사용)

2. 인스턴스의 생성
- 컨스트럭터는 반드시 하나여야 하고, 생략 가능하다.

3. 컨스트럭터
- 컨스트럭터를 둘 이상 쓰면 문법 에러 발생
- 생략하면 빈객체를 생성한다. (내부에서 constructor() {}를 만들어 써줌)

4. 클래스 프로퍼티
- 클래스 프로퍼티는 반드시 컨스트럭터 안에 써야함.
- 클래스 바디에는 메소드만 올 수 있음.

5. 호이스팅

6. getter
    - [].concat() : 프로토타입 메소드 (this는 [], 이런 메소드는 this가 유의미)
    - Math.max()  : 스태틱 메소드 (this가 없음, 그냥 전역)

- 프로퍼티에 접근하는 방식으로 호출한다. (setter도 마찬가지)
- 파라메터가 없다.
- 반드시 무언가를 리턴해야 한다.

7. setter

8. 클래스 상속
    1. extends
    2. super
        - 함수로 사용하면 부모의 컨스트럭터를 호출한다. (부모의 인스턴스를 만든다.)
        - 객체로 사용하면 this와 유사하나 자신이 아니라 부모를 가리킨다. (선언할 때만 super를 쓰면 되고, 생성된 후에 메소드를 쓸 때는 프로토타입 체인을 활용하여 그냥 호출하면 됨)
        - 똑같은 이름의 메소드가 부모, 자신 모두에 존재하면 자신의 것을 먼저 쓴다. (오버라이딩)
    3.static의 상속
        - 클래스는 프로토타입 체인 + 클래스 끼리로 체인으로 상속이 형성되므로, 스태틱 메소드도 상속처럼 사용할 수 있다.