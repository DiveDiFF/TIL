# 6.1 ECMAScript6 - let, const와 블록 레벨 스코프

- ES4는 없음. - 발표 전에 급진적이라는 이유로 내부적으로 철회함
- ES5에서 JSON과 strict mode 추가
- ES6에서 많은 기능이 추가 되었으나, ES4에서 받아들여지지 않았던 것들이 추가된 것. 당시에는 급진적이라 평가 받았으나, 다양한 프레임워크의 발전과 javaScript의 위상이 올라가면서 추가함.
- 그 후 매년 버젼이 올라가 현재 ES8버젼이 최신.
- ECMAScript는 단순히 제안할 뿐이고, 실제로 이를 반영하여 구현하는 것은 브라우저 벤더. 따라서 스펙에 있는 것이 모든 브라우저에서 동일하게 작동하지 않고, 세부적으로는 각각 기능마다도 적용 여부가 다름.

---
## var 키워드의 문제점

1. 함수 레벨 스코프
    1. 전역변수의 남발
    2. for loop 초기화 식에서 사용한 변수(i)를 외부에서도 참조할 수 있다.
2. var 키워드 생략 허용
    1. 함수 레벨에서 선언없이 할당한 변수를 전역에 선언해 줌
3. 중복 선언 허용
    1. 후에 선언한 선언문은 var를 지워줌.(재할당으로 봄)
4. 변수 호이스팅
    1. 변수 선언전에 참조 가능

> 결국 전역변수로 인한 문제들이 많음
> - 전역변수는 유효범위가 넓어 의도치 않은 변경이 일어날 수 있고, 사용이 복잡하게 일어남.

---

## let

1. 블록레벨 스코프 지원

- {} 코드 블록 안에서 let으로 선언한 변수는 해당 코드 블록 레벨 스코프를 가진다.

2. 중복선언의 금지

- 중복선언되면 문법에러를 반환한다.

3. 호이스팅

- let도 호이스팅이 일어난다. 자바 스크립트는 모든 선언문을 호이스팅한다! (변수, 함수, 클래스, 제네레이터 선언문 모두) 다만 let은 호이스팅이 일어나지 않는 것처럼 동작한다.
- var로 선언한 변수를 선언전에 참조하면 undefined (할당은 선언문을 실제로 만나야 이뤄짐)
- let으로 선언한 변수를 선언전에 참조하면 reference error

- var 로 선언한 변수 호이스팅은 실행 컨텍스트가 코드 실행 전에 선언단계, 초기화 단계가 동시에 이뤄지는 반면,
- let으로 선언한 변수 호이스팅은 선언단계만 이뤄지고 아직 초기화 단계는 이뤄지지 않아 일시적 사각 지대에 놓이게 된다.

```javaScript
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2; // 지역 변수
}
```

> 원래는 전역에 있는 전역변수 foo 선언을 참조하여 console.log의 결과는 1이 나와야 한다.
> 하지만 지역 안에서 호이스팅이 이뤄져 같은 스코프에 있는 지역변수 선언이 호이스팅되므로 레퍼런스 에러가 나옴.

4. 클로저

    1. 외부함수와 그 외부함수의 내부에 내부 함수가 있음.
    2. 내부함수가 외부함수의 지역변수를 참조함.
    3. 외부함수가 내부함수를 리턴함(내부함수가 실행컨텍스트에 외부함수보다 더 오래 남아야함. life-cycle이 더 길어야 함)
    4. 이때 외부함수의 실행컨텍스트가 종료되었음에도 내부함수가 참조한 외부함수의 지역변수가 자유변수가 되어 계속 참조되는 현상을 클로저라 한다.

- let도 클로저 현상 발생함.
  - let은 블록레벨스코프를 가지므로, 함수가 아니라도 외부 블록 스코프, 내부 블록 스코프의 스코프 중첩 상황에서 ES5와 같은 스코프가 일어남.

```javaScript
var funcs = [];

// 함수의 배열을 생성하는 for 루프의 i는 for 루프의 코드 블록에서만 유효한 지역 변수이면서 자유 변수이다.
for (let i = 0; i < 3; i++) {
  funcs.push(function () { console.log(i); });
}

// 배열에서 함수를 꺼내어 호출한다
for (var j = 0; j < 3; j++) {
  console.dir(funcs[j]);
  funcs[j]();
}
```

---

## const

1. 선언과 초기화
- 재할당이 금지된다. 선언과 할당이 동시에 이뤄져야 한다.
- 정확히는 참조를 바꿀 수 없다가 정확함. 객체인 경우 객체는 mutable 하므로 객체의 내용을 바꾸는 건 가능하다. (객체의 프로퍼티를 동적생성하는 것도 참조가 바뀌는건 아니므로 가능)
- 5.8번 객체와 변경불가성 참고 (https://poiemaweb.com/js-immutability)

## 결론

1. ES6에서는 var는 안쓴다.
2. 재할당이 필요한 변수는 let을 쓴다.
3. 재할당이 필요없는 기본자료형 (상수 등), 객체형 변수는 const를 쓴다.
